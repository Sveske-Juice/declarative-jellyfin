{
  config,
  lib,
  pkgs,
  ...
}:
with lib; let
  cfg = config.services.declarative-jellyfin;
  genhash = import ./pbkdf2-sha512.nix {inherit pkgs;};
  toXml' = (import ../lib {nixpkgs = pkgs;}).toXMLGeneric;
  isStrList = x: all (x: isString x) x;
  prepass = x:
    if (isAttrs x)
    then
      if !(hasAttr "tag" x)
      then
        attrsets.mapAttrsToList
        (tag: value: {
          inherit tag;
          content = prepass value;
        })
        x
      else if (hasAttr "content" x)
      then {
        tag = x.tag;
        content = prepass x.content;
      }
      else x
    else if (isList x)
    then
      if (isStrList x)
      then
        (map
          (content: {
            tag = "string";
            inherit content;
          })
          x)
      else map prepass x
    else x;

  system =
    cfg.system;
  # // {
  #   # We need to transform cfg.plugins into PluginRepositories for system
  #   PluginRepositories =
  #     lib.attrsets.mapAttrsToList
  #     (name: value: {
  #       tag = "RepositoryInfo";
  #       content = {
  #         Name = builtins.foldl' (a: b: "${a}, ${b}") "Manifest for " (builtins.map (x: x.name) value);
  #         Url = name;
  #       };
  #     })
  #     (
  #       builtins.groupBy (x: x.manifest)
  #       cfg.plugins
  #     );
  # };

  plugins =
    builtins.map
    (plugin:
      plugin
      // {
        package =
          pkgs.stdenvNoCC.mkDerivation
          {
            name = "${plugin.name} v${plugin.version}";
            version = plugin.version;

            src = builtins.fetchurl (with plugin; {
              inherit url sha256;
            });

            nativeBuildInputs = with pkgs; [
              unzip
              jq
            ];

            phases = ["unpackPhase" "buildPhase"];

            unpackPhase = ''
              ${pkgs.unzip}/bin/unzip $src
            '';

            buildPhase = ''
              ${
                if (plugin.targetAbi == "")
                then ''
                  if [ ! -f meta.json ]; then
                    echo "No meta.json found! Please specify the targetAbi (can be found in manifest.json)";
                    exit 1;
                  fi
                ''
                else ''
                  if [ ! -f meta.json ]; then
                    echo '${builtins.toJSON {
                    category = "Unknown";
                    changelog = "Autogenerated by Declarative Jellyfin";
                    description = "Autogenerated by Declarative Jellyfin";
                    guid = let
                      addDashes = uuid: let
                        part1 = builtins.substring 0 8 uuid;
                        part2 = builtins.substring 8 4 uuid;
                        part3 = builtins.substring 12 4 uuid;
                        part4 = builtins.substring 16 4 uuid;
                        part5 = builtins.substring 20 12 uuid;
                      in "${part1}-${part2}-${part3}-${part4}-${part5}";
                    in
                      addDashes (builtins.hashString "sha1" plugin.name);
                    imageUrl = "https://repo.jellyfin.org/releases/plugin/images/jellyfin-plugin-tvdb.png";
                    name = plugin.name;
                    overview = plugin.name;
                    owner = plugin.name;
                    targetAbi = plugin.targetAbi;
                    version = "1.0.0.0";
                  }}' > meta.json
                  fi
                ''
              }

              ${pkgs.jq}/bin/jq '. + {assemblies:[],autoUpdate:false,status:"Active"}' < meta.json > better_meta.json
              mv better_meta.json meta.json


              mkdir $out
              mv * $out/
            '';

            installPhase = "";
          };
      })
    cfg.plugins;

  pluginLinkCommands = builtins.concatStringsSep "\n" (builtins.map
    (plugin:
      /*
      bash
      */
      ''
        echo "Moving ${plugin.package} to ${config.services.jellyfin.configDir}/plugins/${plugin.name}_${plugin.version}"
        # install -Dm 750 -d -o ${config.services.jellyfin.user} -g ${config.services.jellyfin.group} "${plugin.package}" "${config.services.jellyfin.dataDir}/plugins/${plugin.name}_${plugin.version}"
        cp -R "${plugin.package}" "${config.services.jellyfin.dataDir}/plugins/${plugin.name}_${plugin.version}"
      '')
    plugins);

  toXml = tag: x: (toXml' {
    inherit tag;
    attrib = {
      "xmlns:xsi" = "http://www.w3.org/2001/XMLSchema-instance";
      "xmlns:xsd" = "http://www.w3.org/2001/XMLSchema";
    };
    content = prepass x;
  });
  log = "/var/log/jellyfin.txt";
  print = msg: ''echo "${msg}" | tee --append ${log}'';
  jellyfinConfigFiles = {
    "network.xml" = {
      name = "NetworkConfiguration";
      content = cfg.network;
    };
    "encoding.xml" = {
      name = "EncodingOptions";
      content = cfg.encoding;
    };
    "system.xml" = {
      name = "ServerConfiguration";
      content = system;
    };
  };

  # See: https://github.com/jellyfin/jellyfin/blob/master/src/Jellyfin.Database/Jellyfin.Database.Implementations/Enums/PermissionKind.cs
  permissionKindToDBInteger = {
    IsAdministrator = 0;
    IsHidden = 1;
    IsDisabled = 2;
    EnableSharedDeviceControl = 3;
    EnableRemoteAccess = 4;
    EnableLiveTvManagement = 5;
    EnableLiveTvAccess = 6;
    EnableMediaPlayback = 7;
    EnableAudioPlaybackTranscoding = 8;
    EnableVideoPlaybackTranscoding = 9;
    EnableContentDeletion = 10;
    EnableContentDownloading = 11;
    EnableSyncTranscoding = 12;
    EnableMediaConversion = 13;
    EnableAllDevices = 14;
    EnableAllChannels = 15;
    EnableAllFolders = 16;
    EnablePublicSharing = 17;
    EnableRemoteControlOfOtherUsers = 18;
    EnablePlaybackRemuxing = 19;
    ForceRemoteSourceTranscoding = 20;
    EnableCollectionManagement = 21;
    EnableSubtitleManagement = 22;
    EnableLyricManagement = 23;
  };
  subtitleModes = {
    Default = 0;
    Always = 1;
    OnlyForce = 2;
    None = 3;
    Smart = 4;
  };
  dbname = "jellyfin.db";
  nonDBOptions = ["HashedPasswordFile" "Mutable" "Permissions" "_module"];
  sq = "${pkgs.sqlite}/bin/sqlite3 \"${config.services.jellyfin.dataDir}/data/${dbname}\" --";
  options = lib.attrsets.mapAttrsToList (key: value: "${key}") (
    (builtins.removeAttrs
      (
        (import ./options/users.nix {inherit lib;}).options.services.declarative-jellyfin.Users.type.getSubOptions []
      )
      nonDBOptions)
    // {Username = null;}
  );

  sqliteFormat = key: value:
    if (isBool value) # bool -> 1 or 0
    then
      if value
      then "1"
      else "0"
    else if (isNull value) # null -> NULL
    then "NULL"
    else if (key == "SubtitleMode") # SubtitleMode -> 0 | 1 | 2 | 3 | 4
    then subtitleModes.${value}
    else if (isString value)
    then "'${value}'"
    else value;
  sqliteFormatAttrs = attrset:
    builtins.mapAttrs
    (
      name: value: sqliteFormat name value
    )
    attrset;

  optionsNoId = lib.lists.remove "Id" (lib.lists.remove "InternalId" options);
  genUser = index: username: userOpts: let
    mutatedUser =
      builtins.removeAttrs
      (userOpts
        // {
          Username = username;
          Id =
            if !(isNull userOpts.Id)
            then userOpts.Id
            else "$(${pkgs.libuuid}/bin/uuidgen | ${pkgs.coreutils}/bin/tr '[:lower:]' '[:upper:]')";
          InternalId =
            if !(isNull userOpts.InternalId)
            then userOpts.InternalId
            else "$(($maxIndex+${toString (index + 1)}))";
          Password =
            if !(isNull userOpts.HashedPasswordFile)
            then "$(${pkgs.coreutils}/bin/cat \"${userOpts.HashedPasswordFile}\")"
            else "$(${genhash}/bin/genhash -k \"${userOpts.Password}\" -i 210000 -l 128 -u)";
        })
      nonDBOptions;
    userWithNoId = removeAttrs mutatedUser ["Id" "InternalId"];
  in
    /*
    bash
    */
    ''
      userExists=$(${sq} "SELECT 1 FROM Users WHERE Username = '${mutatedUser.Username}'")
      # If the user is mutable, only insert the user if it doesn't already exist, otherwise just overwrite
      if [ ${
        if (userOpts.Mutable)
        then "-z $userExists" # user doesn't exist
        else "-n \"true\""
      } ]; then
        sql="INSERT INTO Users (${concatStringsSep "," options}) VALUES(${concatStringsSep "," (map toString (attrValues (sqliteFormatAttrs mutatedUser)))})"
        # User already exists - don't insert a new Id, just re-use the one already present,
        # so any foreign key relations don't fail because of overwriting with newly generated ID.
        if [ -n "$userExists" ]; then
          ${print "Excluding insertion of Id/InternalId, since user already exists in DB"}
           sql="UPDATE Users SET ${concatStringsSep ",\n" (map (
          {
            fst,
            snd,
          }:
          /*
          bash
          */
          ''${fst} = ${toString (sqliteFormat fst snd)}''
        )
        (lib.lists.zipLists
          optionsNoId
          (attrValues userWithNoId)))} WHERE Username = '${mutatedUser.Username}'"
        fi
        ${print "SQL COMMAND: $sql"}
        res=$(${sq} "$sql")
        ${print "SQL OUTPUT: $res"}

        # Handle user permissions
        ${concatStringsSep "\n" (lib.attrsets.mapAttrsToList (
          permission: enabled:
          /*
          bash
          */
          ''
            userId=$(${sq} "SELECT Id FROM Users WHERE Username = '${mutatedUser.Username}'")
            sql="REPLACE INTO Permissions (Kind, Value, UserId, Permission_Permissions_Guid, RowVersion) VALUES(${toString permissionKindToDBInteger.${permission}}, ${
              if enabled
              then "1"
              else "0"
            }, $(echo "'$userId'"), NULL, 0)"
            ${print "SQL COMMAND: $sql"}
            ${sq} "$sql"
          ''
        )
        userOpts.Permissions)}
      fi
    '';

  # This needs to convert the `options` structure of
  #
  # TypeOptions
  # ├── Series
  # │   ├── MetadataFetchers
  # │   └── ImageFetchers
  # ├── Season
  # │   ├── MetadataFetchers
  # │   └── ImageFetchers
  # └── Episode
  #     ├── MetadataFetchers
  #     └── ImageFetchers
  #
  # To the expected structure in the file of
  #
  # TypeOptions
  # ├── TypeOptions
  # │   ├── Type Series
  # │   ├── MetadataFetchers
  # │   ├── MetadataFetcherOrder
  # │   ├── ImageFetchers
  # │   └── ImageFetcherOrder
  # ├── TypeOptions
  # │   ├── Type Season
  # │   ├── MetadataFetchers
  # │   ├── MetadataFetcherOrder
  # │   ├── ImageFetchers
  # │   └── ImageFetcherOrder
  # └── TypeOptions
  #     ├── Type Episode
  #     ├── MetadataFetchers
  #     ├── MetadataFetcherOrder
  #     ├── ImageFetchers
  #     └── ImageFetcherOrder
  #
  # It also needs to convert PathInfos from a listOf str to listOf MediaPathInfo->Path->String
  prepassedLibraries =
    builtins.mapAttrs
    (name: value:
      value
      // {
        TypeOptions =
          mapAttrsToList
          (name: value: {
            TypeOptions = with value; {
              Type = name;
              inherit MetadataFetchers;
              MetadataFetcherOrder = MetadataFetchers;
              inherit ImageFetchers;
              ImageFetcherOrder = ImageFetchers;
            };
          })
          cfg.libraries.${name}.TypeOptions;
        PathInfos = builtins.map (x: {MediaPathInfo.Path = x;}) value.PathInfos;
      })
    cfg.libraries;

  jellyfinDoneTag = "/var/log/jellyfin-init-done";
  configDerivations = mapAttrs (file: cfg: pkgs.writeText file (toXml cfg.name cfg.content)) jellyfinConfigFiles;
  jellyfin-exec = "${getExe config.services.jellyfin.package} --datadir '${config.services.jellyfin.dataDir}' --configdir '${config.services.jellyfin.configDir}' --cachedir '${config.services.jellyfin.cacheDir}' --logdir '${config.services.jellyfin.logDir}'";
  jellyfin-init =
    pkgs.writeShellScriptBin "jellyfin-init"
    /*
    bash
    */
    ''
        set -euo pipefail
        rm -rf "${jellyfinDoneTag}"
        trap "rm -rf '${jellyfinDoneTag}'" exit

          # u=rwx
          # g=r-x
          # o=---
          umask 027

          install -Dm 774 -o ${config.services.jellyfin.user} -g ${config.services.jellyfin.group} /dev/null "${log}"
          ${print "Log init"}

        # Setup directories
        install -d -m 750 -o ${config.services.jellyfin.user} -g ${config.services.jellyfin.group} "${config.services.jellyfin.configDir}"
        install -d -m 750 -o ${config.services.jellyfin.user} -g ${config.services.jellyfin.group} "${config.services.jellyfin.logDir}"
        install -d -m 750 -o ${config.services.jellyfin.user} -g ${config.services.jellyfin.group} "${config.services.jellyfin.cacheDir}"
        install -d -m 750 -o ${config.services.jellyfin.user} -g ${config.services.jellyfin.group} "${config.services.jellyfin.dataDir}/metadata"
        install -d -m 750 -o ${config.services.jellyfin.user} -g ${config.services.jellyfin.group} "${config.services.jellyfin.dataDir}/playlists"
        install -d -m 750 -o ${config.services.jellyfin.user} -g ${config.services.jellyfin.group} "${config.services.jellyfin.dataDir}/wwwroot"
        install -d -m 750 -o ${config.services.jellyfin.user} -g ${config.services.jellyfin.group} "${config.services.jellyfin.dataDir}/plugins/configurations"

          # Install each config
          ${concatStringsSep "\n"
        (mapAttrsToList
          (file: path: ''install -Dm 640 "${path}" "${config.services.jellyfin.configDir}/${file}"'')
          configDerivations)}

          ${
        lib.optionalString cfg.system.IsStartupWizardCompleted
        /*
        bash
        */
        ''
          # We need to generate a valid migrations.xml file if it's a first run and
          # `services.declarative-jellyfin.system.IsStartupWizardCompleted=true`
          # otherwise jellyfin will try and run deprecated/old migrations, see:
          # https://github.com/jellyfin/jellyfin/issues/12254
          if [ ! -f "${config.services.jellyfin.configDir}/migrations.xml" ]; then
            echo "First time run and no migrations.xml. We run jellyfin once to generate it..."
            echo "Starting jellyfin with IsStartupWizardCompleted = false"
            ${pkgs.xmlstarlet}/bin/xmlstarlet ed -L -u "//IsStartupWizardCompleted" -v "false" "${config.services.jellyfin.configDir}/system.xml"
            ${jellyfin-exec} & disown
            echo "Waiting for jellyfin to generate migrations.xml"
            until [ -f "${config.services.jellyfin.configDir}/migrations.xml" ]
            do
              sleep 1
            done
            sleep 5
            echo "migrations.xml generated! Restarting jellyfin..."
            echo "migrations.xml:"
            cat "${config.services.jellyfin.configDir}/migrations.xml"
            ${pkgs.procps}/bin/pkill -15 -f ${config.services.jellyfin.package}
            echo "Waiting for jellyfin to shut down properly"
            while ${pkgs.ps}/bin/ps axg | ${pkgs.gnugrep}/bin/grep -vw grep | ${pkgs.gnugrep}/bin/grep -w ${config.services.jellyfin.package} > /dev/null; do sleep 1 && printf "."; done
            echo "Jellyfin terminated. Resetting with IsStartupWizardCompleted set to true"
            ${pkgs.xmlstarlet}/bin/xmlstarlet ed -L -u "//IsStartupWizardCompleted" -v "true" "${config.services.jellyfin.configDir}/system.xml"
          fi
        ''
      }

        # Make sure there is a database
        if [ ! -e "${config.services.jellyfin.dataDir}/data/${dbname}" ]; then
          ${print "No DB found. First time run detected. Launching jellyfin once to generate initial config + DB..."}
          ${jellyfin-exec} & disown

          ${print "Waiting for jellyfin finish startup"}
          until [ -f "${config.services.jellyfin.dataDir}/data/${dbname}" ]
          do
            sleep 1
          done
          sleep 5
          ${print "Initial jellyfin setup done"}
          ${pkgs.procps}/bin/pkill -15 -f ${config.services.jellyfin.package}
          ${print "Waiting for jellyfin to shut down properly"}
          while ${pkgs.ps}/bin/ps axg | ${pkgs.gnugrep}/bin/grep -vw grep | ${pkgs.gnugrep}/bin/grep -w ${config.services.jellyfin.package} > /dev/null; do sleep 1 && printf "."; done
          cat "${config.services.jellyfin.configDir}/migrations.xml"
          ${print "Jellyfin terminated"}
        fi

      # Rotating backups
      ${
        lib.optionalString cfg.backups
        /*
        bash
        */
        ''
          # Make sure ${cfg.backupDir} exists
          install -d -m 775 -o ${config.services.jellyfin.user} -g ${config.services.jellyfin.group} "${cfg.backupDir}"
          backupName="${cfg.backupDir}/backup_$(date +%Y%m%d%H%M%S).tar.gz"

          install -Dm 775 -o ${config.services.jellyfin.user} -g ${config.services.jellyfin.group} /dev/null "$backupName"
          ${pkgs.gnutar}/bin/tar -c --exclude "${removePrefix "/" cfg.backupDir}" -C / ${removePrefix "/" config.services.jellyfin.logDir} -C / ${removePrefix "/" config.services.jellyfin.dataDir} -C / ${removePrefix "/" config.services.jellyfin.configDir} -C / ${removePrefix "/" config.services.jellyfin.cacheDir} -f - | ${pkgs.gzip}/bin/gzip > "$backupName"

          # Rotate backups
          num_backups=$(ls -1 "${cfg.backupDir}" | wc -l)
          num_backups_to_remove=$((num_backups - ${toString cfg.backupCount}))

          if [ $num_backups_to_remove -gt 0 ]; then
            old_backups=$(ls -1 "${cfg.backupDir}" | sort | head -n "$num_backups_to_remove")
            for old_backup in $old_backups; do
              rm "${cfg.backupDir}/$old_backup"
              ${print "Purged backup: $old_backup"}
            done
          fi
        ''
      }

        maxIndex=$(${sq} 'SELECT InternalId FROM Users ORDER BY InternalId DESC LIMIT 1')
        if [ -z "$maxIndex" ]; then
          maxIndex="1"
        fi
        ${print "Max index: $maxIndex"}

        # Generate each user
        ${
        concatStringsSep "\n"
        (
          map ({
            fst,
            snd,
          }:
            genUser fst snd cfg.Users.${snd})
          (
            lib.lists.zipLists
            (
              builtins.genList (x: x)
              (builtins.length (builtins.attrValues cfg.Users))
            )
            (builtins.attrNames cfg.Users)
          )
        )
      }

        # Handle libraries
        ${builtins.concatStringsSep "\n" (mapAttrsToList (name: value: let
        path = "${config.services.jellyfin.dataDir}/root/default/${name}";
      in
        /*
        bash
        */
        ''
          install -Dm 740 '${pkgs.writeText "options.xml" (toXml "LibraryOptions" value)}' "${path}/options.xml"
          # Create .mblink files foreach path in library
          ${
            concatStringsSep "\n"
            (map (pathInfo:
              /*
              bash
              */
              ''
                install -Dm 740 /dev/null "${config.services.jellyfin.dataDir}/root/default/${name}/${baseNameOf pathInfo.MediaPathInfo.Path}.mblink"
                echo -n "${pathInfo.MediaPathInfo.Path}" > "${config.services.jellyfin.dataDir}/root/default/${name}/${baseNameOf pathInfo.MediaPathInfo.Path}.mblink"
              '')
            value.PathInfos)
          }
        '')
      prepassedLibraries)}

        # Install libraries
        ${pluginLinkCommands}

        touch '${jellyfinDoneTag}'
        ${jellyfin-exec}
    '';
in {
  config =
    mkIf cfg.enable
    {
      services.jellyfin = {
        enable = true;
        package = cfg.package.overrideAttrs (old: {
          buildInputs = old.buildInputs ++ (builtins.map (x: x.package) plugins);
        });
        inherit (cfg) user group dataDir configDir cacheDir logDir;
      };

      networking.firewall.allowedTCPPorts = lib.mkIf cfg.openFirewall [cfg.network.PublicHttpPort cfg.network.PublicHttpsPort];
      systemd.services.jellyfin.serviceConfig.ExecStart = lib.mkForce "+${jellyfin-init}/bin/jellyfin-init";
    };
}
